---
title: "Modelado_v01"
author: "JOM"
date: "27/4/2017"
output: 
    html_document:
      fig_width: 11
      fig_height: 10
      fig_caption: true
      toc: true
      toc_float: true      
---

```{r setup, include=FALSE, echo=FALSE, message=FALSE}
# require(devtools)
# devtools::install_github("hafen/trelliscopejs")
# devtools::install_github("vqv/ggbiplot")
devtools::install_github("natydasilva/PPforest")
# library(trelliscopejs)
# library(ggbiplot)
#
cargar=function (x) {
  if (! require(x,character.only = TRUE)) {
    install.packages(x,repos="http://cran.rstudio.com/")
    require(x,character.only = TRUE)
  }
}
#
pkgs=c('plyr','caret','zoo','stringr','utils',
       'parallel','xtable','readr','Cubist','xgboost',
       'rbokeh','dplyr','ggiraph','e1071',
       'xtable','SimilarityMeasures','gbm',
       'reshape2','scales','formattable','doMC',
       'svglite','lubridate','grid','gridExtra',
       'cowplot','devtools')
lapply(pkgs, cargar)
#
```

## Cargamos datos físicos proporcionados por Tecnalia

Del preprocesado inicial se han preparado los objetos:

* **fechas**: Vector de fechas en las que hay datos registrados "YYYY-mm-dd"
* **lval**: data.frame con agregacion de todos los datos T,CO2,HR de todas las salas
* **matdat**: data.frame que para cada día apunta a que indices start/end apuntan al objeto lval para identificar los valores por sala y variable física
* **ldat**: Lista R que para cada fecha almacena un data frame con los valores de cada combinación sala-variable y hora (X) que se ha medido ese día.


```{r lectura,warning=FALSE,echo=FALSE}
setwd('~/git/P01')
if (file.exists("Datos.RData")) {
  load("Datos.RData")
} else {
  stop("Error: No hay datos PREPROCESADOS del problema")
}
#
lv = colnames(ldat[[length(ldat)]])
llv= strsplit(lv,'-')
lv = unique(sort(ldply(llv,function(x){return(x[1])})[,1]))
salas = unique(sort(ldply(llv,function(x){return(str_replace(x[3],
                  '.csv',''))})[,1]))
rm(llv)
```

## Selección de Patrones
Si bien, a la vista de las conclusiones del preprocesado, existen 
dudas razonables sobre reglas de certidumbre en la ocupación
de espacios y su reflejo en las variables de control, vamos 
a adoptar una estrategia de 00:00 a 07:30 Personal en 

* **Sala de Estar**: Ocupada de 00:00 a 07:30. Vacías 11:00 a 18:00
* **Comedor**: Ocupado de 13:10 a 13:55 y de 19:10 a 19:55. Vacío de 22:00 a 07:30.

Vamos a trabajar en crear datasets para esos dos contextos en los rangos 
previstos

```{r seleccion,warning=FALSE}
#
# Preparamos un dataframe con las variables y ocupación a 1
seleccion = function(x,horas,sala,lv,estado) {
  desde = str_split(horas,"-")[[1]][1]
  hasta = str_split(horas,"-")[[1]][2]
  desde = paste(desde,":00",sep="")
  desde = paste(strftime(x$X[1],"%Y-%m-%d")," ",desde,sep="")
  hasta = paste(strftime(x$X[1],"%Y-%m-%d")," ",hasta,sep="")
  desde = as.POSIXct(desde)
  hasta = as.POSIXct(hasta)
  df    = expand.grid(lv,sala)
  vdf   = apply(df,1,function(x){return(paste(x,collapse=".*"))})
  lc    = unlist(lapply(vdf,function(x,y){grep(x,colnames(y))},x))
  rd    = x[(as.POSIXct(x$X) >= as.POSIXct(desde) & 
             as.POSIXct(x$X) <= as.POSIXct(hasta)),lc]
  if ( is.null(rd) ) {
    return(NULL)
  }
  if(length(rd)==0){
    return(NULL)
  }
  if (is.vector(rd)) {
    return(NULL)
  }
  if ( nrow(rd) > 0 ) {
    rd[,"estado"]=estado
    return(rd)
  } else {
    return(NULL)
  }
}
#
nom = function(x) {
  return(unlist(lapply(x,function(x){
    return(strsplit(x,'-')[[1]][1])})))
}
#
setwd('~/git/P01')
if (file.exists("DmodelC.RData")) {
  load("DmodelC.RData")
} else {
  a1=ldply(ldat,seleccion,"13:05-13:55","Comedor",lv,1)[,2:5]
  colnames(a1)=nom(colnames(a1))
  a2=ldply(ldat,seleccion,"22:30-23:55","Comedor",lv,0)[,2:5]
  colnames(a2)=nom(colnames(a2))
  a3=ldply(ldat,seleccion,"19:05-19:55","Comedor",lv,1)[,2:5]
  colnames(a3)=nom(colnames(a3))
  a4=ldply(ldat,seleccion,"05:00-07:00","Comedor",lv,0)[,2:5]
  colnames(a4)=nom(colnames(a4))
  dcom = rbind(a1,a2,a3,a4)
  rm(a1,a2,a3,a4)
  #
  idx = apply(dcom,1,function(x){sum(is.na(x))}) == 0
  dcom= dcom[idx,]
  rm(idx)
  save(ldat,dcom,fechas,file="DmodelC.RData")
}
#
if (file.exists("DmodelH.RData")) {
  load("DmodelH.RData")
} else {
  a1=ldply(ldat,seleccion,"00:00-07:30","Habitacion 1",lv,1)[,2:5]
  colnames(a1)=nom(colnames(a1))
  a2=ldply(ldat,seleccion,"11:00-18:00","Habitacion 1",lv,0)[,2:5]
  colnames(a2)=nom(colnames(a2))
  a3=ldply(ldat,seleccion,"00:00-07:30","Habitacion 2",lv,1)[,2:5]
  colnames(a3)=nom(colnames(a3))
  a4=ldply(ldat,seleccion,"11:00-18:00","Habitacion 2",lv,0)[,2:5]
  colnames(a4)=nom(colnames(a4))
  dcom = rbind(a1,a2,a3,a4)
  colnames(dcom)=c("estado",lv[-length(lv)])
  #
  idx = apply(dcom,1,function(x){sum(is.na(x))}) == 0
  dcom= dcom[idx,]
  save(ldat,dcom,fechas,file="DmodelH.RData")
}
#
#
```

## Preparación para modelar las Habitaciones

Sobre la estructura de datos DCOM vamos a realizar un modelo sobre
las Habitaciones.

```{r modelos,warning=FALSE}
#
# names(getModelInfo())
# getModelInfo()$cubist$type
cmodel = function(X,Y){
  model_1.1 = "train(X, Y, method='gbm', 
                trControl=myControl,
                tuneGrid=expand.grid(n.trees=seq(100,500,100), 
                          interaction.depth=seq(3,18,5), 
                          shrinkage = seq(0.01,0.1,0.03),
                          n.minobsinnode=100),verbose=FALSE)"
  model_1.2 = "train(X, Y, method='AdaBag', 
                trControl=myControl, 
                tuneGrid=expand.grid(mfinal=10^(3:4), 
                                     maxdepth=seq(10,25,5)))"
  model_1.3 = "train(X, Y, method='ctree2', 
                 trControl=myControl,tuneGrid=
                     expand.grid(mincriterion=0.95,maxdepth=50))"
  model_1.4 = "train(X, Y, method='C5.0', 
                  trControl=myControl, trace=FALSE,
                  tuneGrid=expand.grid(winnow=c(TRUE,FALSE),
                  trials=seq(1,20,5),model=c('tree','rules')))"
  model_1.5 = "train(X, Y, method='svmRadial',trControl=myControl,
                  tuneGrid=expand.grid(C=10^(-2:2),sigma=c(10^(-3:1))))"
  model_1.6 = "train(X, Y, method='xgbTree', 
                     trControl=myControl,tuneGrid=expand.grid(
                            nrounds=seq(100,1000,200),max_depth=c(3,5,10),
                            eta=c(0.01,0.1,0.5),gamma=c(0.001,0.01),
                            colsample_bytree=0.7,min_child_weight = 1,
                            subsample = c(.8, 1)))"
  model_1.7 = "train(X, Y, method='nnet',trControl=myControl,
                  tuneGrid=expand.grid(size=seq(ncol(X),round(6*ncol(X)),3), 
                            decay=c(1.e-5,1.e-2)),
                  preProcess = c('center', 'scale'),trace=FALSE,linout=TRUE,
                  maxit=10000, reltol=1.0e-11, abstol=1.0e-6)"
  all_models= ls(pattern="^model_.*")
    all.models =list()
  for (i in all_models) {
    all.models[[length(all.models)+1]] = eval(parse(
      text=gsub('\n','', get(i))))
  }
  names(all.models) = sapply(all.models, function(x) x$method)    
  return(all.models)
}
#
registerDoMC(20) # asking for using 16 cores.
#
folds=10
repeats=1
myControl = trainControl(method='cv', number=folds, 
                    repeats=repeats, returnResamp='none', 
                    returnData=FALSE, savePredictions=TRUE, 
                    verboseIter=FALSE, allowParallel=TRUE)
#
if (file.exists("ModelsT-C.RData")) {
  load("ModelsT-C.RData")
} else {
  set.seed(998)
  dcom[,"estado"] = as.factor(dcom[,"estado"])  
  pprf = PPforest::PPforest(data=dcom,class="estado",lambda=0.2,
                    size.tr=0.7, m=500,size.p=0.5,PPmethod='LDA')
  
#
  idx  = createDataPartition(dcom$estado,p=0.75,list=FALSE)
  train= dcom[idx,]
  test = dcom[-idx,]
  rf.dcom = randomForest(formula=estado~.,data=train,proximity=TRUE)
  X  = train[,-which(colnames(train)=="estado")]
  Y  = train[,which(colnames(train)=="estado")]
  Xt = test[,-which(colnames(train)=="estado")]
  Yt = test[,which(colnames(train)=="estado")]
  lmd= cmodel(X,Y)
  save(lmd,X,Y,Xt,Yt,idx,dcom,file="ModelsT-H.RData")
}
#
# if (file.exists("ModelsT-H.RData")) {
#   load("ModelsT-H.RData")
# } else {
#   set.seed(998)
#   dcom[,"estado"] = as.factor(dcom[,"estado"])
#   idx  = createDataPartition(dcom$estado,p=0.75,list=FALSE)
#   train= dcom[idx,]
#   test = dcom[-idx,]  
#   X  = train[,-1]
#   Y  = train[,1]
#   Xt = test[,-1]
#   Yt = test[,1]
#   lmd= cmodel(X,Y)
#   save(lmd,X,Y,Xt,Yt,idx,dcom,file="ModelsT-H.RData")
# }
#
```

    